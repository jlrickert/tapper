package keg

// Package config provides versioned configuration management for the KEG
// application. It supports loading, parsing, converting, and accessing
// configuration data with environment variable expansion and version
// migration.

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	kegurl "github.com/jlrickert/tapper/pkg/keg_url"
	"gopkg.in/yaml.v3"
)

const (
	KegConfigSchemaURL      = "https://raw.githubusercontent.com/jlrickert/tapper/main/schemas/keg-config.json"
	kegConfigSchemaModeline = "# yaml-language-server: $schema=" + KegConfigSchemaURL + "\n"
)

// ConfigV1 KegConfigV1 represents the initial version of the KEG configuration
// specification.
type ConfigV1 struct {
	// Kegv is the version of the specification.
	Kegv string `yaml:"kegv"`

	// Updated indicates when the keg was last indexed.
	Updated string `yaml:"updated,omitempty"`

	// Title is the title of the KEG worklog or project.
	Title string `yaml:"title,omitempty"`

	// URL is the main URL where the KEG can be found.
	URL string `yaml:"url,omitempty"`

	// Creator is the URL or identifier of the creator of the KEG.
	Creator string `yaml:"creator,omitempty"`

	// State indicates the current state of the KEG (e.g., living, archived).
	State string `yaml:"state,omitempty"`

	// Summary provides a brief description or summary of the KEG content.
	Summary string `yaml:"summary,omitempty"`

	// Indexes is a list of index entries that link to related files or nodes.
	Indexes []IndexEntry `yaml:"indexes,omitempty"`

	path string
}

// ConfigV2 KegConfigV2 represents the second (current) version of the KEG configuration
// specification. It extends V1 with additional fields such as Links and Zekia.
type ConfigV2 struct {
	// Kegv is the version of the specification.
	Kegv string `yaml:"kegv"`

	// Updated indicates when the keg was last indexed.
	Updated string `yaml:"updated,omitempty"`

	// Title is the title of the KEG worklog or project.
	Title string `yaml:"title,omitempty"`

	// URL is the main URL where the KEG can be found.
	URL string `yaml:"url,omitempty"`

	// Creator is the URL or identifier of the creator of the KEG.
	Creator string `yaml:"creator,omitempty"`

	// State indicates the current state of the KEG (e.g., living, archived).
	State string `yaml:"state,omitempty"`

	// Summary provides a brief description or summary of the KEG content.
	Summary string `yaml:"summary,omitempty"`

	// Links holds a list of LinkEntry objects representing related links or
	// references in the configuration.
	Links []LinkEntry `yaml:"links,omitempty"`

	// Indexes is a list of index entries that link to related files or nodes.
	Indexes []IndexEntry `yaml:"indexes,omitempty"`

	Entities map[string]EntityEntry `yaml:"entities,omitempty"`

	Tags map[string]string `yaml:"tags,omitempty"`

	path string
}

// LinkEntry represents a named link in the KEG configuration.
type LinkEntry struct {
	Alias string `json:"alias"` // Alias for the link
	URL   string `json:"url"`   // URL of the link
}

// IndexEntry represents an entry in the indexes list in the KEG configuration.
type IndexEntry struct {
	File    string `yaml:"file"`
	Summary string `yaml:"summary"`
	Tags    string `yaml:"tags,omitempty"` // boolean tag query; omit for core/unfiltered indexes
}

type EntityEntry struct {
	ID      int    `yaml:"id"`
	Summary string `yaml:"summary"`
}

// Config KegConfig is an alias for the latest configuration version. Update this alias
// when introducing a newer configuration version.
type Config = ConfigV2

// toV2 converts a ConfigV1 value to the ConfigV2 representation.
func (c *ConfigV1) toV2() *ConfigV2 {
	return &ConfigV2{
		Kegv:     ConfigV2VersionString,
		Updated:  c.Updated,
		Title:    c.Title,
		URL:      c.URL,
		Creator:  c.Creator,
		State:    c.State,
		Summary:  c.Summary,
		Links:    nil, // No links in v1, so leave as nil
		Indexes:  c.Indexes,
		Entities: nil,
		Tags:     nil,
		path:     "",
	}
}

type ConfigOption = func(cfg *Config)

func NewConfig(options ...ConfigOption) *Config {
	cfg := &Config{
		Kegv:    ConfigV2VersionString,
		Updated: "2025-08-19 12:54:28Z",
		Title:   "KEG Worklog for tapper",
		URL:     "https://keg.jlrickert.me/@example/user",
		Creator: "git@github.com:jlrickert/jlrickert.git",
		State:   "living",
		Summary: `KEG worklog and documentation for the "tapper" project.Use this keg as
	the canonical place for project notes, Zekia prompt contexts, and generated
	indices that drive tooling and automation for the repo.

	Key points:
	- Contains documentation and contexts consumed by the Zekia utility (see
	zekia.includes.docs which discovers **/meta.yaml and merges contexts/roles).
	- Provides autogenerated indices (dex/changes.md, dex/nodes.tsv, dex/links,
	dex/backlinks, dex/tags) used by keg tooling for fast lookups and hub pages.
	- Keep the updated line as the first line
	update it when you change content
	or metadata so indexers detect changes.
	- Keep the zero node as a placeholder for planned content and update creator
	and url to reflect the keg's primary repo/location.`,
		Links: []LinkEntry{
			{
				Alias: "jlrickert",
				URL:   "https://keg.jlrickert.me/@jlrickert/public",
			},
		},
		Indexes: []IndexEntry{
			{
				File: "dex/backlinks", Summary: "all incoming links",
			},
			{
				File: "dex/changes.md", Summary: "latest changes",
			},
			{
				File: "dex/links", Summary: "all outgoing links",
			},
			{
				File: "dex/nodes.tsv", Summary: "all nodes by id",
			},
			{
				File: "dex/tags", Summary: "all tags",
			},
		},
	}
	for _, f := range options {
		f(cfg)
	}
	return cfg
}

// ParseKegConfig parses raw YAML config data into the latest Config version.
// It detects the "kegv" version field and performs migration from earlier
// versions when necessary.
func ParseKegConfig(data []byte) (*Config, error) {
	var configV2 ConfigV2

	// Detect version by unmarshaling into a generic map
	var raw map[string]any
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return &configV2, fmt.Errorf("failed to parse keg data: %w", errors.Join(ErrParse, err))
	}

	// Check for "kegv" version field
	version, ok := raw["kegv"].(string)
	if !ok {
		return &configV2, fmt.Errorf("missing or invalid kegv version field")
	}

	switch version {
	case ConfigV1VersionString:
		var configV1 ConfigV1
		if err := yaml.Unmarshal(data, &configV1); err != nil {
			return &configV2, err
		}
		return configV1.toV2(), nil
	case ConfigV2VersionString:
		if err := yaml.Unmarshal(data, &configV2); err != nil {
			return &configV2, err
		}
	default:
		return &configV2, fmt.Errorf("unsupported config version: %s", version)
	}

	return &configV2, nil
}

func (kc *Config) ResolveAlias(alias string) (*kegurl.Target, error) {
	for _, entry := range kc.Links {
		if alias == entry.Alias {
			kt, err := kegurl.Parse(entry.URL)
			if err != nil {
				return nil, fmt.Errorf("could resolve alias: %w", err)
			}
			return kt, nil
		}
	}
	return nil, fmt.Errorf("alias %s not found: %w", alias, ErrNotExist)
}

// ToYAML serializes the Config to YAML.
func (kc *Config) ToYAML() ([]byte, error) {
	body, err := yaml.Marshal(kc)
	if err != nil {
		return nil, err
	}
	return append([]byte(kegConfigSchemaModeline), body...), nil
}

// ToJSON serializes the Config to JSON.
func (kc *Config) ToJSON() ([]byte, error) {
	return json.Marshal(kc)
}

func (kc *Config) String() string {
	out, _ := kc.ToYAML()
	return string(out)
}

func (kc *Config) Touch(t time.Time) {
	kc.Updated = t.Format(time.RFC3339)
}

// AddEntity adds or updates an entity entry by entity name.
func (kc *Config) AddEntity(name string, id int, summary string) error {
	if kc == nil {
		return fmt.Errorf("config is nil")
	}

	name = strings.TrimSpace(name)
	summary = strings.TrimSpace(summary)
	if name == "" {
		return fmt.Errorf("entity name is required")
	}
	if id <= 0 {
		return fmt.Errorf("entity id must be greater than zero")
	}

	if kc.Entities == nil {
		kc.Entities = map[string]EntityEntry{}
	}
	kc.Entities[name] = EntityEntry{
		ID:      id,
		Summary: summary,
	}
	return nil
}

// AddTag adds or updates a tag summary by tag name.
func (kc *Config) AddTag(name, summary string) error {
	if kc == nil {
		return fmt.Errorf("config is nil")
	}
	name = strings.TrimSpace(name)
	summary = strings.TrimSpace(summary)
	if name == "" {
		return fmt.Errorf("tag name is required")
	}
	if summary == "" {
		return fmt.Errorf("tag summary is required")
	}

	if kc.Tags == nil {
		kc.Tags = map[string]string{}
	}
	kc.Tags[name] = summary
	return nil
}
